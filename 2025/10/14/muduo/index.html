<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"hoshea99.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script><meta name="description" content="项目总结描述模拟muduo网络库，用C++11的新特性实现了非阻塞IO复用的高并发TCP服务器模型核心（TCPServer），用C++11的新特性取代了Boost，同时提升了Buffer等组件的性能，实现了0第三方库的依赖，仅需linux内核支持。 实现 整体采用non-blocking+IO-multiplexing+loop线程的设计框架，其中线程模型采用one loop per thread"><meta property="og:type" content="article"><meta property="og:title" content="muduo"><meta property="og:url" content="https://hoshea99.github.io/2025/10/14/muduo/index.html"><meta property="og:site_name" content="Hoshea&#39;s Blog"><meta property="og:description" content="项目总结描述模拟muduo网络库，用C++11的新特性实现了非阻塞IO复用的高并发TCP服务器模型核心（TCPServer），用C++11的新特性取代了Boost，同时提升了Buffer等组件的性能，实现了0第三方库的依赖，仅需linux内核支持。 实现 整体采用non-blocking+IO-multiplexing+loop线程的设计框架，其中线程模型采用one loop per thread"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2025-10-14T02:59:42.000Z"><meta property="article:modified_time" content="2025-10-17T03:36:24.962Z"><meta property="article:author" content="Hoshea"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://hoshea99.github.io/2025/10/14/muduo/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hoshea99.github.io/2025/10/14/muduo/","path":"2025/10/14/muduo/","title":"muduo"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>muduo | Hoshea's Blog</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Hoshea's Blog</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93"><span class="nav-number">1.</span> <span class="nav-text">项目总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.</span> <span class="nav-text">概念介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Reactor%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">Reactor模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">基本工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6"><span class="nav-number">2.1.2.</span> <span class="nav-text">主要组件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="nav-number">2.2.</span> <span class="nav-text">阻塞和非阻塞IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E4%BE%8B%E5%AD%90"><span class="nav-number">2.2.2.</span> <span class="nav-text">具体例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5IO"><span class="nav-number">2.3.</span> <span class="nav-text">同步和异步IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">定义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.</span> <span class="nav-text">项目问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reactor%E6%A8%A1%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%93%E7%8E%B0%E7%9A%84"><span class="nav-number">3.1.1.</span> <span class="nav-text">Reactor模型是如何体现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">3.1.2.</span> <span class="nav-text">工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9one-loop-per-thread%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.1.3.</span> <span class="nav-text">为什么选择one loop per thread模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E7%BD%91%E7%BB%9C%E5%BA%93%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.1.4.</span> <span class="nav-text">使用这个网络库可以做什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">3.1.5.</span> <span class="nav-text">实现一个服务器需要考虑哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%AD%90Reactor%EF%BC%8C%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95%E7%94%A8%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95"><span class="nav-number">3.1.6.</span> <span class="nav-text">如何分配子Reactor，轮询算法用到了什么负载均衡算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="nav-number">3.1.7.</span> <span class="nav-text">为什么使用多线程而不是多进程？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-number">3.2.</span> <span class="nav-text">核心模块实现细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel"><span class="nav-number">3.2.1.</span> <span class="nav-text">Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Channel%E5%A6%82%E4%BD%95%E4%B8%8EEventloop%E5%92%8CEpollpoller%E4%BA%A4%E4%BA%92%EF%BC%9F"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">Channel如何与Eventloop和Epollpoller交互？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%9F%EF%BC%88%E8%AF%BB%E5%86%99%E9%94%99%E8%AF%AF%E7%AD%89%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">如何处理不同的事件类型？（读写错误等等）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Epollpoller"><span class="nav-number">3.2.2.</span> <span class="nav-text">Epollpoller</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll%E5%AF%B9%E6%AF%94poll%E5%92%8Cselect%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">epoll对比poll和select的优势是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll%E7%9A%84LT%E5%92%8CET%E4%BD%A0%E9%80%89%E6%8B%A9%E4%BA%86%E5%93%AA%E7%A7%8D%EF%BC%8C%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">epoll的LT和ET你选择了哪种，优势是什么？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventLoop"><span class="nav-number">3.2.3.</span> <span class="nav-text">EventLoop</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#loop%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">loop工作流程是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8%EF%BC%9F%EF%BC%88%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F%EF%BC%89"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">如何实现跨线程调用？（如何保证线程安全？）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TcpConnection"><span class="nav-number">3.2.4.</span> <span class="nav-text">TcpConnection</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%EF%BC%9F"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">连接的生命周期如何管理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8shared-ptr"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">为何使用shared_ptr?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.2.5.</span> <span class="nav-text">Buffer设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E4%B8%89%E4%B8%AA%E6%8C%87%E9%92%88%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">为什么采用三个指针，各自的作用是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%EF%BC%9F"><span class="nav-number">3.2.5.2.</span> <span class="nav-text">如何实现高效的数据读写？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11%E7%89%B9%E6%80%A7%E5%BA%94%E7%94%A8"><span class="nav-number">3.3.</span> <span class="nav-text">C++11特性应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C"><span class="nav-number">3.4.</span> <span class="nav-text">项目经验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">3.5.</span> <span class="nav-text">网络编程基础</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hoshea</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">38</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://hoshea99.github.io/2025/10/14/muduo/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Hoshea"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hoshea's Blog"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="muduo | Hoshea's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">muduo</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-14 10:59:42" itemprop="dateCreated datePublished" datetime="2025-10-14T10:59:42+08:00">2025-10-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-10-17 11:36:24" itemprop="dateModified" datetime="2025-10-17T11:36:24+08:00">2025-10-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/proj/" itemprop="url" rel="index"><span itemprop="name">proj</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>模拟muduo网络库，用C++11的新特性实现了非阻塞IO复用的高并发TCP服务器模型核心（TCPServer），用C++11的新特性取代了Boost，同时提升了Buffer等组件的性能，实现了0第三方库的依赖，仅需linux内核支持。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>整体采用non-blocking+IO-multiplexing+loop线程的设计框架，其中线程模型采用one loop per thread的多线程服务端网络编程模型，结合Reactor模型进行实现。<br>其中主Reactor（1线程）专职于accept()，同时采用EPOLLEXCLUSIVE避免惊群。子Reactor（N默认等于CPU核心数），轮询处理已连接的客户端数据。</li><li>去掉了Muduo库中的Boost依赖，使用C++11的标准：<ol><li>使用了智能指针：unique，shared，weak对Poller，Channel等的内存资源释放，对TcpConnection建立和Channel绑定等</li><li>使用atomic原子操作类型对状态量进行保护，用unique_lock替代lock_guard</li></ol></li><li>缓冲区参照Netty设计，使用prepend，read和write三个指针的设计，划分缓冲区数据</li><li>日志系统采用同步输出方式，使用snprintf进行INFO、DEBUG、ERROR、FATAL四个等级的格式化输出…</li><li>使用开发的网络库实现了EchoServer</li></ul><span id="more"></span><h1 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h1><h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><p>Reactor模型是一种事件驱动的并发编程模型，主要用于处理大量并发IO操作。</p><h3 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h3><ol><li>注册感兴趣的事件（读就绪，写就绪事件）</li><li>Reactor（事件分发器）监听所有注册的事件</li><li>事件发生时，Reactor分发给相应的Handler（事件处理器）</li><li>事件处理器执行具体的业务逻辑</li></ol><h3 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h3><ul><li><p>Reactor</p><p>事件分发器，使用了多路IO复用技术比如select，poll，epoll</p></li><li><p>Handlers</p><p>事件处理器，比如Acceptor，ReadHandler</p></li><li><p>Demultiplexer</p><p>多路分发器，比如epoll</p></li></ul><h2 id="阻塞和非阻塞IO"><a href="#阻塞和非阻塞IO" class="headerlink" title="阻塞和非阻塞IO"></a>阻塞和非阻塞IO</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>阻塞IO</p><p>当进程发起IO操作时，进程会被挂起，直到操作完成才返回</p><p>在等待期间，进程不能执行其他任务</p></li><li><p>非阻塞IO</p><p>当进程发起IO操作时，立即返回，不管操作是否完成</p><p>进程需要主动检查操作是否完成</p></li></ul><h3 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h3><ul><li><p>阻塞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞模式下的 read 操作</span></span><br><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// ... 连接设置 ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">read</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer));  <span class="comment">// 阻塞直到有数据或出错</span></span><br><span class="line"><span class="comment">// 只有当有数据可读时，read 才会返回</span></span><br></pre></td></tr></table></figure></li><li><p>非阻塞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置为非阻塞模式</span></span><br><span class="line"><span class="type">int</span> flags = <span class="built_in">fcntl</span>(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">fcntl</span>(sockfd, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">read</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">        <span class="comment">// 暂时没有数据可读，需要稍后重试</span></span><br><span class="line">        <span class="comment">// 程序可以去做其他事情</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 真正的错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 成功读取 n 字节数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="同步和异步IO"><a href="#同步和异步IO" class="headerlink" title="同步和异步IO"></a>同步和异步IO</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li><p>同步IO</p><p>应用程序主动等待IO操作完成</p><p>IO操作期间，应用程序被阻塞或需要主动检查</p></li><li><p>异步IO</p><p>应用程序发起IO操作后立即返回</p><p>由内核在IO操作完成后通知应用程序</p></li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="项目问题"><a href="#项目问题" class="headerlink" title="项目问题"></a>项目问题</h2><h3 id="Reactor模型是如何体现的"><a href="#Reactor模型是如何体现的" class="headerlink" title="Reactor模型是如何体现的"></a>Reactor模型是如何体现的</h3><p>Reactor模型的核心组成就是reactor，handlers和demultiplexer，其中：</p><p>Reactor对应的是Eventloop</p><p>handlers对应的是channel类，分装了文件描述符和处理回调函数</p><p>demultiplexer对应的就是epoller，监听所有的channel</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li>Acceptor（维护的是主Reactor）监听新连接，当新连接到达时，Acceptor创建一个Tcpconnection对象，轮询注册到一个SubReactor的EpollPoller中。</li><li>Subloop通过Epoll监听套接字是否有事件触发，如果有，EpollPoller返回活跃的Channel，EventLoop主动调用Channel的HandleEvent去执行对应回调。</li><li>Channel回调函数是用户设置的，实现了业务逻辑的解耦。</li></ul><p>Muduo属于多Reactor多线程设计，一个主Reactor+N个子Reactor。工作流程中，主Reactor通过轮询把新连接分配给子Reactor中，子Reactor通过EpollPoller监听事件并触发Channel回调，实现高并发处理。</p><h3 id="为什么选择one-loop-per-thread模型"><a href="#为什么选择one-loop-per-thread模型" class="headerlink" title="为什么选择one loop per thread模型"></a>为什么选择one loop per thread模型</h3><p>这个模型是一种常见的并发网络编程模式，他有四个优点：<br>1. 简化并发编程，每个线程独立运行自己的事件循环。<br>2. 减少锁竞争，事件处理在单个线程内完成<br>3. 不同连接由不同线程处理，一个连接的问题不会影响其他连接<br>4. 每个线程可以绑定不同的CPU核心</p><h3 id="使用这个网络库可以做什么？"><a href="#使用这个网络库可以做什么？" class="headerlink" title="使用这个网络库可以做什么？"></a>使用这个网络库可以做什么？</h3><p>TCP长连接服务，比如即时通讯、聊天服务器、金融交易系统、代理服务器</p><h3 id="实现一个服务器需要考虑哪些？"><a href="#实现一个服务器需要考虑哪些？" class="headerlink" title="实现一个服务器需要考虑哪些？"></a>实现一个服务器需要考虑哪些？</h3><ol><li><p>线程模型的设计</p><p>one loop per thread</p><p>如何实现跨线程调用？</p><p>跨线程调用的安全方案为：外部线程通过<code>runInLoop()</code>方法提交任务，任务被加入队列并唤醒事件循环.EventLoop在下次迭代中处理队列任务。使用<code>wakeupfd</code>实现跨线程唤醒，即发送一个单字节数据。</p></li><li><p>协议处理</p><p>PLC HTTP处理</p></li><li><p>性能优化</p><p>负载均衡算法</p></li><li><p>连接生命周期</p><p>muduo库中的TcpConnection继承自enable_shared_from_this，使用shared_ptr进行生命周期的管理。</p><p>TcpServer这里创建的是shared_ptr的TCPconnection，拥有主要的所有权；连接建立时，Channel只持有弱引用，观察还是否存在。用户回调只会获得临时的shared_ptr（如果存在即tie_.lock()临时提升，提升后出了作用域引用计数则-1）。</p><p>为什么要这么做？因为tcpconnector的回调传给channel，但是channel调用的时候tcpconnector可能已经被destroy了。</p></li></ol><h3 id="如何分配子Reactor，轮询算法用到了什么负载均衡算法"><a href="#如何分配子Reactor，轮询算法用到了什么负载均衡算法" class="headerlink" title="如何分配子Reactor，轮询算法用到了什么负载均衡算法"></a>如何分配子Reactor，轮询算法用到了什么负载均衡算法</h3><ol><li>轮询分配 按顺序依次分配</li><li>加权分配 根据子Reactor的处理能力分配不同权重（CPU不同核心访问内存速度不一定一样）</li><li>最少连接数 分配给当前连接数最少的线程</li></ol><h3 id="为什么使用多线程而不是多进程？"><a href="#为什么使用多线程而不是多进程？" class="headerlink" title="为什么使用多线程而不是多进程？"></a>为什么使用多线程而不是多进程？</h3><p>线程更轻量，性能和资源开销更小；数据共享（连接状态和上下文）和通信效率更高；更适配reactor模型。</p><h2 id="核心模块实现细节"><a href="#核心模块实现细节" class="headerlink" title="核心模块实现细节"></a>核心模块实现细节</h2><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><h4 id="Channel如何与Eventloop和Epollpoller交互？"><a href="#Channel如何与Eventloop和Epollpoller交互？" class="headerlink" title="Channel如何与Eventloop和Epollpoller交互？"></a>Channel如何与Eventloop和Epollpoller交互？</h4><p>Epollpoller和eventloop里都维护了channel，eventloop轮询时调用epollwait，每一轮返回有事件的fd，通过维护的map，和fd，获取到对应的channel，eventloop直接触发对应channel的回调handleevent</p><h4 id="如何处理不同的事件类型？（读写错误等等）"><a href="#如何处理不同的事件类型？（读写错误等等）" class="headerlink" title="如何处理不同的事件类型？（读写错误等等）"></a>如何处理不同的事件类型？（读写错误等等）</h4><p>Channel首先通过enableRead、enableWrite等方法处理可读可写事件，设置为感兴趣事件，返回时通过revent确定具体事件类型，在handleevent函数中，选择对应的分支选择对应的函数进行处理</p><h3 id="Epollpoller"><a href="#Epollpoller" class="headerlink" title="Epollpoller"></a>Epollpoller</h3><h4 id="epoll对比poll和select的优势是什么？"><a href="#epoll对比poll和select的优势是什么？" class="headerlink" title="epoll对比poll和select的优势是什么？"></a>epoll对比poll和select的优势是什么？</h4><ol><li>时间复杂度低，只返回就绪的fd</li><li>连接较多时，性能更加稳定</li><li>监控的fd上限仅受系统内存限制</li></ol><h4 id="epoll的LT和ET你选择了哪种，优势是什么？"><a href="#epoll的LT和ET你选择了哪种，优势是什么？" class="headerlink" title="epoll的LT和ET你选择了哪种，优势是什么？"></a>epoll的LT和ET你选择了哪种，优势是什么？</h4><p>LT，只要fd处于就绪状态就会持续通知，开发简易性优先的场景，不容易遗漏事件。但是要注意在数据量大的时候主动开关epollout。</p><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><h4 id="loop工作流程是什么？"><a href="#loop工作流程是什么？" class="headerlink" title="loop工作流程是什么？"></a>loop工作流程是什么？</h4><ol><li>事件收集 通过系统调用（比如epoll_wait）收集所有就绪的IO事件，返回后填充活跃Channel列表</li><li>事件分发 遍历每个活跃的Channel，调用每个Channel的handleEvent方法，Channel根据具体事件调用注册的回调</li><li>异步任务 执行其他线程提交到本线程的任务</li></ol><h4 id="如何实现跨线程调用？（如何保证线程安全？）"><a href="#如何实现跨线程调用？（如何保证线程安全？）" class="headerlink" title="如何实现跨线程调用？（如何保证线程安全？）"></a>如何实现跨线程调用？（如何保证线程安全？）</h4><p>首先介绍一下Muduo核心的线程模型：One Loop Per Thread，即每个EventLoop对象严格绑定一个特定的线程。</p><p>跨线程调用的安全方案为：外部线程通过runInLoop()方法提交任务，任务被加入队列并唤醒事件循环，EventLoop在下次迭代中处理队列任务。使用wakeupfd实现跨线程唤醒，即发送一个单字节数据。</p><h3 id="TcpConnection"><a href="#TcpConnection" class="headerlink" title="TcpConnection"></a>TcpConnection</h3><h4 id="连接的生命周期如何管理？"><a href="#连接的生命周期如何管理？" class="headerlink" title="连接的生命周期如何管理？"></a>连接的生命周期如何管理？</h4><p>muduo库中的TcpConnection继承自enable_shared_from_this，使用shared_ptr进行生命周期的管理。</p><p>TcpServer这里创建的是shared_ptr的TCPconnection，拥有主要的所有权；连接建立时，Channel只持有弱引用，观察还是否存在。用户回调只会获得临时的shared_ptr（如果存在即tie_.lock()临时提升，提升后出了作用域引用计数则-1）。</p><h4 id="为何使用shared-ptr"><a href="#为何使用shared-ptr" class="headerlink" title="为何使用shared_ptr?"></a>为何使用shared_ptr?</h4><ol><li>tcpserver拥有shared_ptr是为了保证服务运行期间持续存活，避免意外提前释放。</li><li>与之配合的weak_ptr能有效地避免在调用回调时已经被释放。</li></ol><h3 id="Buffer设计"><a href="#Buffer设计" class="headerlink" title="Buffer设计"></a>Buffer设计</h3><h4 id="为什么采用三个指针，各自的作用是什么？"><a href="#为什么采用三个指针，各自的作用是什么？" class="headerlink" title="为什么采用三个指针，各自的作用是什么？"></a>为什么采用三个指针，各自的作用是什么？</h4><p>BUffer的三个指针分别是readerIndex&#x2F;writerIndex&#x2F;以及首尾指针。</p><p>读指针标记已接收但是还没被应用层消费的数据，写指针标记可写内存区域的起始位置。</p><p>在读缓冲区，读指针是待处理数据的起始位置，写指针是新数据追加位置；而在写缓冲区，读指针是待发送数据的起始位置，写指针是新数据追加位置。</p><h4 id="如何实现高效的数据读写？"><a href="#如何实现高效的数据读写？" class="headerlink" title="如何实现高效的数据读写？"></a>如何实现高效的数据读写？</h4><ol><li>减少内存拷贝的优化<br>直接暴露内部指针给用户，避免数据拷贝。<br>使用readv&#x2F;writev，单次系统调用填充多个缓冲区，当主缓冲区空间不足时，自动使用栈上的缓冲区。</li><li>动态扩容<br>如果可以先优化Buffer内的内存分配，如果还是不够再扩容，可以考虑指数增长。</li></ol><h2 id="C-11特性应用"><a href="#C-11特性应用" class="headerlink" title="C++11特性应用"></a>C++11特性应用</h2><ol><li><p>你用了哪些智能指针 为什么在这些场景下用这些特定的智能指针？</p><p>unique_ptr、shared_ptr以及weak_ptr都用到了。</p><p>unique_ptr用到的地方比较多，比如tcpconnector的channel、socket；tcpserver里的acceptor；eventloop里的poller、wake_channel等<br>shared_ptr和weak_ptr成对使用，tcpserver新建tcpconnection时用的是shared_ptr，但是channel使用weakptr去接收tcpconnection，因为Channel持有tcpconnection的引用，但是tcpconnection拥有channel的所有权，会出现循环引用</p></li><li><p>atomic和mutex的选择标准是什么？</p><p>优先选择atomic的情况：1. 简单的数据类型 2. 仅需保证单个变量的原子性 3. 没有依赖关系 4. 高频操作<br>局限在不支持多变量同步或者符合变量</p><p>优先选择mutex：1. 复杂数据结构，比如map vector 2. 多变量操作 3. 可以配合条件变量，执行复杂逻辑<br>局限在可能引发死锁</p></li><li><p>C++11的移动语义在你的项目中有什么应用？</p><p>回调函数的赋值操作使用到了move</p></li><li><p>当TcpConnection被多线程持有，shared_from_this在析构中调用是否安全？</p><p>不安全，此时引用计数可能已经变成0了。在析构中如果一定需要用，需要加一个weak_ptr的判断，不过根本原则是在析构函数中禁止调用。</p></li></ol><h2 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h2><ol><li><p>在实现过程中遇到的最大挑战，如何解决的？</p><p>多线程下TcpConnection对象在IO线程和业务线程间共享，会不会出现这么一个问题：IO线程在发送数据的时候，业务线程想要delete conn这样会导致崩溃。<br>所以考虑使用shared_ptr和weak_ptr配合使用。即在进行操作时（无论是handleclose韩式handleread等操作），线程都使用weakptr去接收Tcpconnection，如果此时还存在则升级到shared_ptr进行操作，操作结束后引用计数自动-1，避免了对象提前被析构的问题。所有的销毁操作都延迟到IO线程中的事件循环中去执行。</p></li><li><p>如果让你继续优化这个项目，你会从哪些方面着手？</p><p>日志库的添加；现在只有IO线程和简单的工作线程，考虑添加其他复杂的工作线程。</p></li><li><p>从muduo源码中你能学到哪些优秀的代码设计？</p><p>Reactor模式的高效实现；多Reactor线程模型；对象生命周期的控制；Buffer的设计；跨线程的任务提交；接口设计和函数命名</p></li></ol><h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><ol><li><p>TCP服务器的基本工作流程</p><p>创建监听套接字-&gt;创建事件监听器-&gt;事件循环-&gt;处理新连接-&gt;处理IO-&gt;关闭连接</p></li><li><p>非阻塞IO相比阻塞IO的优势和劣势</p><p>优点：1. 高并发 2. 资源利用率高 3. 响应速度更快 4. 避免线程阻塞<br>缺点：1. 编程复杂度高 2. 调试困难 3. 持续重试读写导致的CPU空转风险</p></li></ol></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2025/10/13/packaged-task/" rel="prev" title="packaged_task"><i class="fa fa-angle-left"></i> packaged_task</a></div><div class="post-nav-item"><a href="/2025/10/17/%E9%80%9A%E4%BF%A1%E7%BD%91%E5%85%B3/" rel="next" title="通信网关">通信网关 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Hoshea</span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>