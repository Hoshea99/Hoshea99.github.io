<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"hoshea99.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script><meta property="og:type" content="website"><meta property="og:title" content="Hoshea&#39;s Blog"><meta property="og:url" content="https://hoshea99.github.io/index.html"><meta property="og:site_name" content="Hoshea&#39;s Blog"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="Hoshea"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://hoshea99.github.io/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Hoshea's Blog</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Hoshea's Blog</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hoshea</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">36</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://hoshea99.github.io/2025/10/14/muduo/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Hoshea"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hoshea's Blog"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content=" | Hoshea's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2025/10/14/muduo/" class="post-title-link" itemprop="url">muduo</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-14 10:59:42 / 修改时间：16:22:17" itemprop="dateCreated datePublished" datetime="2025-10-14T10:59:42+08:00">2025-10-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/proj/" itemprop="url" rel="index"><span itemprop="name">proj</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>模拟muduo网络库，用C++11的新特性实现了非阻塞IO复用的高并发TCP服务器模型核心（TCPServer），用C++11的新特性取代了Boost，同时提升了Buffer等组件的性能，实现了0第三方库的依赖，仅需linux内核支持。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>整体采用non-blocking+IO-multiplexing+loop线程的设计框架，其中线程模型采用one loop per thread的多线程服务端网络编程模型，结合Reactor模型进行实现。<br>其中主Reactor（1线程）专职于accept()，同时采用EPOLLEXCLUSIVE避免惊群。子Reactor（N默认等于CPU核心数），轮询处理已连接的客户端数据。</li><li>去掉了Muduo库中的Boost依赖，使用C++11的标准：<ol><li>使用了智能指针：unique，shared，weak对Poller，Channel等的内存资源释放，对TcpConnection建立和Channel绑定等</li><li>使用atomic原子操作类型对状态量进行保护，用unique_lock替代lock_guard</li></ol></li><li>缓冲区参照Netty设计，使用prepend，read和write三个指针的设计，划分缓冲区数据</li><li>日志系统采用同步输出方式，使用snprintf进行INFO、DEBUG、ERROR、FATAL四个等级的格式化输出…</li><li>使用开发的网络库实现了EchoServer</li></ul><h1 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h1><h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><p>Reactor模型是一种事件驱动的并发编程模型，主要用于处理大量并发IO操作。</p><h3 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h3><ol><li>注册感兴趣的事件（读就绪，写就绪事件）</li><li>Reactor（事件分发器）监听所有注册的事件</li><li>事件发生时，Reactor分发给相应的Handler（事件处理器）</li><li>事件处理器执行具体的业务逻辑</li></ol><h3 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h3><ul><li><p>Reactor</p><p>事件分发器，使用了多路IO复用技术比如select，poll，epoll</p></li><li><p>Handlers</p><p>事件处理器，比如Acceptor，ReadHandler</p></li><li><p>Demultiplexer</p><p>多路分发器，比如epoll</p></li></ul><h2 id="阻塞和非阻塞IO"><a href="#阻塞和非阻塞IO" class="headerlink" title="阻塞和非阻塞IO"></a>阻塞和非阻塞IO</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>阻塞IO</p><p>当进程发起IO操作时，进程会被挂起，直到操作完成才返回</p><p>在等待期间，进程不能执行其他任务</p></li><li><p>非阻塞IO</p><p>当进程发起IO操作时，立即返回，不管操作是否完成</p><p>进程需要主动检查操作是否完成</p></li></ul><h3 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h3><ul><li><p>阻塞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞模式下的 read 操作</span></span><br><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// ... 连接设置 ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">read</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer));  <span class="comment">// 阻塞直到有数据或出错</span></span><br><span class="line"><span class="comment">// 只有当有数据可读时，read 才会返回</span></span><br></pre></td></tr></table></figure></li><li><p>非阻塞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置为非阻塞模式</span></span><br><span class="line"><span class="type">int</span> flags = <span class="built_in">fcntl</span>(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">fcntl</span>(sockfd, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">read</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">        <span class="comment">// 暂时没有数据可读，需要稍后重试</span></span><br><span class="line">        <span class="comment">// 程序可以去做其他事情</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 真正的错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 成功读取 n 字节数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="同步和异步IO"><a href="#同步和异步IO" class="headerlink" title="同步和异步IO"></a>同步和异步IO</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li><p>同步IO</p><p>应用程序主动等待IO操作完成</p><p>IO操作期间，应用程序被阻塞或需要主动检查</p></li><li><p>异步IO</p><p>应用程序发起IO操作后立即返回</p><p>由内核在IO操作完成后通知应用程序</p></li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="项目问题"><a href="#项目问题" class="headerlink" title="项目问题"></a>项目问题</h2><h3 id="Reactor模型是如何体现的"><a href="#Reactor模型是如何体现的" class="headerlink" title="Reactor模型是如何体现的"></a>Reactor模型是如何体现的</h3><p>Reactor模型的核心组成就是reactor，handlers和demultiplexer，其中：</p><p>Reactor对应的是Eventloop</p><p>handlers对应的是channel类，分装了文件描述符和处理回调函数</p><p>demultiplexer对应的就是epoller，监听所有的channel</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li>Acceptor（维护的是主Reactor）监听新连接，当新连接到达时，Acceptor创建一个Tcpconnection对象，轮询注册到一个SubReactor的EpollPoller中。</li><li>Subloop通过Epoll监听套接字是否有事件触发，如果有，EpollPoller返回活跃的Channel，EventLoop主动调用Channel的HandleEvent去执行对应回调。</li><li>Channel回调函数是用户设置的，实现了业务逻辑的解耦。</li></ul><p>Muduo属于多Reactor多线程设计，一个主Reactor+N个子Reactor。工作流程中，主Reactor通过轮询把新连接分配给子Reactor中，子Reactor通过EpollPoller监听事件并触发Channel回调，实现高并发处理。</p><h3 id="为什么选择one-loop-per-thread模型"><a href="#为什么选择one-loop-per-thread模型" class="headerlink" title="为什么选择one loop per thread模型"></a>为什么选择one loop per thread模型</h3><p>这个模型是一种常见的并发网络编程模式，他有四个优点：<br>1. 简化并发编程，每个线程独立运行自己的事件循环。<br>2. 减少锁竞争，事件处理在单个线程内完成<br>3. 不同连接由不同线程处理，一个连接的问题不会影响其他连接<br>4. 每个线程可以绑定不同的CPU核心</p><h3 id="使用这个网络库可以做什么？"><a href="#使用这个网络库可以做什么？" class="headerlink" title="使用这个网络库可以做什么？"></a>使用这个网络库可以做什么？</h3><p>TCP长连接服务，比如即时通讯、聊天服务器、金融交易系统、代理服务器</p><h3 id="实现一个服务器需要考虑哪些？"><a href="#实现一个服务器需要考虑哪些？" class="headerlink" title="实现一个服务器需要考虑哪些？"></a>实现一个服务器需要考虑哪些？</h3><ol><li><p>线程模型的设计</p><p>one loop per thread</p><p>如何实现跨线程调用？</p><p>跨线程调用的安全方案为：外部线程通过<code>runInLoop()</code>方法提交任务，任务被加入队列并唤醒事件循环.EventLoop在下次迭代中处理队列任务。使用<code>wakeupfd</code>实现跨线程唤醒，即发送一个单字节数据。</p></li><li><p>协议处理</p><p>PLC HTTP处理</p></li><li><p>性能优化</p><p>负载均衡算法</p></li><li><p>连接生命周期</p><p>muduo库中的TcpConnection继承自enable_shared_from_this，使用shared_ptr进行生命周期的管理。</p><p>TcpServer这里创建的是shared_ptr的TCPconnection，拥有主要的所有权；连接建立时，Channel只持有弱引用，观察还是否存在。用户回调只会获得临时的shared_ptr（如果存在即tie_.lock()临时提升，提升后出了作用域引用计数则-1）。</p><p>为什么要这么做？因为tcpconnector的回调传给channel，但是channel调用的时候tcpconnector可能已经被destroy了。</p></li></ol><h3 id="如何分配子Reactor，轮询算法用到了什么负载均衡算法"><a href="#如何分配子Reactor，轮询算法用到了什么负载均衡算法" class="headerlink" title="如何分配子Reactor，轮询算法用到了什么负载均衡算法"></a>如何分配子Reactor，轮询算法用到了什么负载均衡算法</h3><ol><li>轮询分配 按顺序依次分配</li><li>加权分配 根据子Reactor的处理能力分配不同权重（CPU不同核心访问内存速度不一定一样）</li><li>最少连接数 分配给当前连接数最少的线程</li></ol><h3 id="为什么使用多线程而不是多进程？"><a href="#为什么使用多线程而不是多进程？" class="headerlink" title="为什么使用多线程而不是多进程？"></a>为什么使用多线程而不是多进程？</h3><p>线程更轻量，性能和资源开销更小；数据共享（连接状态和上下文）和通信效率更高；更适配reactor模型。</p><h2 id="核心模块实现细节"><a href="#核心模块实现细节" class="headerlink" title="核心模块实现细节"></a>核心模块实现细节</h2><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><h4 id="Channel如何与Eventloop和Epollpoller交互？"><a href="#Channel如何与Eventloop和Epollpoller交互？" class="headerlink" title="Channel如何与Eventloop和Epollpoller交互？"></a>Channel如何与Eventloop和Epollpoller交互？</h4><p>Epollpoller和eventloop里都维护了channel，eventloop轮询时调用epollwait，每一轮返回有事件的fd，通过维护的map，和fd，获取到对应的channel，eventloop直接触发对应channel的回调handleevent</p><h4 id="如何处理不同的事件类型？（读写错误等等）"><a href="#如何处理不同的事件类型？（读写错误等等）" class="headerlink" title="如何处理不同的事件类型？（读写错误等等）"></a>如何处理不同的事件类型？（读写错误等等）</h4><p>Channel首先通过enableRead、enableWrite等方法处理可读可写事件，设置为感兴趣事件，返回时通过revent确定具体事件类型，在handleevent函数中，选择对应的分支选择对应的函数进行处理</p><h3 id="Epollpoller"><a href="#Epollpoller" class="headerlink" title="Epollpoller"></a>Epollpoller</h3><h4 id="epoll对比poll和select的优势是什么？"><a href="#epoll对比poll和select的优势是什么？" class="headerlink" title="epoll对比poll和select的优势是什么？"></a>epoll对比poll和select的优势是什么？</h4><ol><li>时间复杂度低，只返回就绪的fd</li><li>连接较多时，性能更加稳定</li><li>监控的fd上限仅受系统内存限制</li></ol><h4 id="epoll的LT和ET你选择了哪种，优势是什么？"><a href="#epoll的LT和ET你选择了哪种，优势是什么？" class="headerlink" title="epoll的LT和ET你选择了哪种，优势是什么？"></a>epoll的LT和ET你选择了哪种，优势是什么？</h4><p>LT，只要fd处于就绪状态就会持续通知，开发简易性优先的场景，不容易遗漏事件。但是要注意在数据量大的时候主动开关epollout。</p><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><h4 id="loop工作流程是什么？"><a href="#loop工作流程是什么？" class="headerlink" title="loop工作流程是什么？"></a>loop工作流程是什么？</h4><ol><li>事件收集 通过系统调用（比如epoll_wait）收集所有就绪的IO事件，返回后填充活跃Channel列表</li><li>事件分发 遍历每个活跃的Channel，调用每个Channel的handleEvent方法，Channel根据具体事件调用注册的回调</li><li>异步任务 执行其他线程提交到本线程的任务</li></ol><h4 id="如何实现跨线程调用？（如何保证线程安全？）"><a href="#如何实现跨线程调用？（如何保证线程安全？）" class="headerlink" title="如何实现跨线程调用？（如何保证线程安全？）"></a>如何实现跨线程调用？（如何保证线程安全？）</h4><p>首先介绍一下Muduo核心的线程模型：One Loop Per Thread，即每个EventLoop对象严格绑定一个特定的线程。</p><p>跨线程调用的安全方案为：外部线程通过runInLoop()方法提交任务，任务被加入队列并唤醒事件循环，EventLoop在下次迭代中处理队列任务。使用wakeupfd实现跨线程唤醒，即发送一个单字节数据。</p><h3 id="TcpConnection"><a href="#TcpConnection" class="headerlink" title="TcpConnection"></a>TcpConnection</h3><h4 id="连接的生命周期如何管理？"><a href="#连接的生命周期如何管理？" class="headerlink" title="连接的生命周期如何管理？"></a>连接的生命周期如何管理？</h4><p>muduo库中的TcpConnection继承自enable_shared_from_this，使用shared_ptr进行生命周期的管理。</p><p>TcpServer这里创建的是shared_ptr的TCPconnection，拥有主要的所有权；连接建立时，Channel只持有弱引用，观察还是否存在。用户回调只会获得临时的shared_ptr（如果存在即tie_.lock()临时提升，提升后出了作用域引用计数则-1）。</p><h4 id="为何使用shared-ptr"><a href="#为何使用shared-ptr" class="headerlink" title="为何使用shared_ptr?"></a>为何使用shared_ptr?</h4><ol><li>tcpserver拥有shared_ptr是为了保证服务运行期间持续存活，避免意外提前释放。</li><li>与之配合的weak_ptr能有效地避免在调用回调时已经被释放。</li></ol><h3 id="Buffer设计"><a href="#Buffer设计" class="headerlink" title="Buffer设计"></a>Buffer设计</h3><h4 id="为什么采用三个指针，各自的作用是什么？"><a href="#为什么采用三个指针，各自的作用是什么？" class="headerlink" title="为什么采用三个指针，各自的作用是什么？"></a>为什么采用三个指针，各自的作用是什么？</h4><p>BUffer的三个指针分别是readerIndex&#x2F;writerIndex&#x2F;以及首尾指针。</p><p>读指针标记已接收但是还没被应用层消费的数据，写指针标记可写内存区域的起始位置。</p><p>在读缓冲区，读指针是待处理数据的起始位置，写指针是新数据追加位置；而在写缓冲区，读指针是待发送数据的起始位置，写指针是新数据追加位置。</p><h4 id="如何实现高效的数据读写？"><a href="#如何实现高效的数据读写？" class="headerlink" title="如何实现高效的数据读写？"></a>如何实现高效的数据读写？</h4><ol><li>减少内存拷贝的优化<br>直接暴露内部指针给用户，避免数据拷贝。<br>使用readv&#x2F;writev，单次系统调用填充多个缓冲区，当主缓冲区空间不足时，自动使用栈上的缓冲区。</li><li>动态扩容<br>如果可以先优化Buffer内的内存分配，如果还是不够再扩容，可以考虑指数增长。</li></ol><h2 id="C-11特性应用"><a href="#C-11特性应用" class="headerlink" title="C++11特性应用"></a>C++11特性应用</h2><ol><li><p>你用了哪些智能指针 为什么在这些场景下用这些特定的智能指针？</p><p>unique_ptr、shared_ptr以及weak_ptr都用到了。</p><p>unique_ptr用到的地方比较多，比如tcpconnector的channel、socket；tcpserver里的acceptor；eventloop里的poller、wake_channel等<br>shared_ptr和weak_ptr成对使用，tcpserver新建tcpconnection时用的是shared_ptr，但是channel使用weakptr去接收tcpconnection，因为Channel持有tcpconnection的引用，但是tcpconnection拥有channel的所有权，会出现循环引用</p></li><li><p>atomic和mutex的选择标准是什么？</p><p>优先选择atomic的情况：1. 简单的数据类型 2. 仅需保证单个变量的原子性 3. 没有依赖关系 4. 高频操作<br>局限在不支持多变量同步或者符合变量</p><p>优先选择mutex：1. 复杂数据结构，比如map vector 2. 多变量操作 3. 可以配合条件变量，执行复杂逻辑<br>局限在可能引发死锁</p></li><li><p>C++11的移动语义在你的项目中有什么应用？</p><p>回调函数的赋值操作使用到了move</p></li><li><p>当TcpConnection被多线程持有，shared_from_this在析构中调用是否安全？</p><p>不安全，此时引用计数可能已经变成0了。在析构中如果一定需要用，需要加一个weak_ptr的判断，不过根本原则是在析构函数中禁止调用。</p></li></ol><h2 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h2><ol><li><p>在实现过程中遇到的最大挑战，如何解决的？</p><p>多线程下TcpConnection对象在IO线程和业务线程间共享，会不会出现这么一个问题：IO线程在发送数据的时候，业务线程想要delete conn这样会导致崩溃。<br>所以考虑使用shared_ptr和weak_ptr配合使用。即在进行操作时（无论是handleclose韩式handleread等操作），线程都使用weakptr去接收Tcpconnection，如果此时还存在则升级到shared_ptr进行操作，操作结束后引用计数自动-1，避免了对象提前被析构的问题。所有的销毁操作都延迟到IO线程中的事件循环中去执行。</p></li><li><p>如果让你继续优化这个项目，你会从哪些方面着手？</p><p>日志库的添加；现在只有IO线程和简单的工作线程，考虑添加其他复杂的工作线程。</p></li><li><p>从muduo源码中你能学到哪些优秀的代码设计？</p><p>Reactor模式的高效实现；多Reactor线程模型；对象生命周期的控制；Buffer的设计；跨线程的任务提交；接口设计和函数命名</p></li></ol><h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><ol><li><p>TCP服务器的基本工作流程</p><p>创建监听套接字-&gt;创建事件监听器-&gt;事件循环-&gt;处理新连接-&gt;处理IO-&gt;关闭连接</p></li><li><p>非阻塞IO相比阻塞IO的优势和劣势</p><p>优点：1. 高并发 2. 资源利用率高 3. 响应速度更快 4. 避免线程阻塞<br>缺点：1. 编程复杂度高 2. 调试困难 3. 持续重试读写导致的CPU空转风险</p></li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://hoshea99.github.io/2025/10/13/packaged-task/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Hoshea"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hoshea's Blog"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content=" | Hoshea's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2025/10/13/packaged-task/" class="post-title-link" itemprop="url">packaged_task</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-13 22:43:08 / 修改时间：22:49:00" itemprop="dateCreated datePublished" datetime="2025-10-13T22:43:08+08:00">2025-10-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p><code>packaged_task</code> 是 C++11 引入的一个重要组件，它可以将可调用对象（函数、lambda、函数对象等）包装起来，并将其返回值与一个 <code>future</code> 对象关联，从而方便地获取异步操作的结果。</p><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包装普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(add)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在另一个线程中执行</span></span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(move(task), <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; endl; <span class="comment">// 输出: Result: 30</span></span><br></pre></td></tr></table></figure><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>智能移动不能复制</p><h2 id="重置任务"><a href="#重置任务" class="headerlink" title="重置任务"></a>重置任务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">([]&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;)</span></span>;</span><br><span class="line"><span class="built_in">task</span>(); <span class="comment">// 第一次执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务已执行，需要重置才能再次使用</span></span><br><span class="line">task.<span class="built_in">reset</span>(); <span class="comment">// 重置任务状态</span></span><br><span class="line">future&lt;<span class="type">int</span>&gt; fut2 = task.<span class="built_in">get_future</span>();</span><br><span class="line"><span class="built_in">task</span>(); <span class="comment">// 可以再次执行</span></span><br></pre></td></tr></table></figure><h1 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h1><p>可以看线程池一文的第二种实现方法</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://hoshea99.github.io/2025/10/13/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Hoshea"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hoshea's Blog"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content=" | Hoshea's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2025/10/13/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">归并排序</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-13 20:06:40 / 修改时间：20:14:13" itemprop="dateCreated datePublished" datetime="2025-10-13T20:06:40+08:00">2025-10-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/alg/" itemprop="url" rel="index"><span itemprop="name">alg</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="comment">// 假设数组最大长度为 1e5</span></span><br><span class="line"><span class="type">int</span> tmp[N];             <span class="comment">// 全局定义的临时数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.判边界</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.定分界点</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递归排序子序列</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid), <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 3.归并排序（双指针法）</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    <span class="comment">// 某个子序列走到最后了，将另一个序列剩余部分加入到 tmp 中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将排序结果 tmp 重新覆盖掉 q</span></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://hoshea99.github.io/2025/10/13/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Hoshea"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hoshea's Blog"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content=" | Hoshea's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2025/10/13/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">快速排序</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-13 20:06:29 / 修改时间：20:09:02" itemprop="dateCreated datePublished" datetime="2025-10-13T20:06:29+08:00">2025-10-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/alg/" itemprop="url" rel="index"><span itemprop="name">alg</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="挖坑法"><a href="#挖坑法" class="headerlink" title="挖坑法"></a>挖坑法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void quick_sort(int a[], int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    if (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int i,j,x;</span><br><span class="line"> </span><br><span class="line">        i = l;</span><br><span class="line">        j = r;</span><br><span class="line">        x = a[i];</span><br><span class="line">        while (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            while(i &lt; j &amp;&amp; a[j] &gt; x)</span><br><span class="line">                j--; // 从右向左找第一个小于x的数</span><br><span class="line">            if(i &lt; j)</span><br><span class="line">                a[i++] = a[j];</span><br><span class="line">            while(i &lt; j &amp;&amp; a[i] &lt; x)</span><br><span class="line">                i++; // 从左向右找第一个大于x的数</span><br><span class="line">            if(i &lt; j)</span><br><span class="line">                a[j--] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = x;</span><br><span class="line">        quick_sort(a, l, i-1); /* 递归调用 */</span><br><span class="line">        quick_sort(a, i+1, r); /* 递归调用 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://hoshea99.github.io/2025/10/13/lru/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Hoshea"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hoshea's Blog"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content=" | Hoshea's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2025/10/13/lru/" class="post-title-link" itemprop="url">lru</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-13 20:02:14 / 修改时间：20:03:52" itemprop="dateCreated datePublished" datetime="2025-10-13T20:02:14+08:00">2025-10-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/alg/" itemprop="url" rel="index"><span itemprop="name">alg</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>lru使用了双向链表维护访问顺序，使用哈希表进行了O(1)复杂度的查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node* prev;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> k = <span class="number">0</span>, <span class="type">int</span> v = <span class="number">0</span>) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    Node* dummy; <span class="comment">// 哨兵节点</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node*&gt; key_to_node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一个节点（抽出一本书）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node* x)</span> </span>&#123;</span><br><span class="line">        x-&gt;prev-&gt;next = x-&gt;next;</span><br><span class="line">        x-&gt;next-&gt;prev = x-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表头添加一个节点（把一本书放在最上面）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(Node* x)</span> </span>&#123;</span><br><span class="line">        x-&gt;prev = dummy;</span><br><span class="line">        x-&gt;next = dummy-&gt;next;</span><br><span class="line">        x-&gt;prev-&gt;next = x;</span><br><span class="line">        x-&gt;next-&gt;prev = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 key 对应的节点，同时把该节点移到链表头部</span></span><br><span class="line">    <span class="function">Node* <span class="title">get_node</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = key_to_node.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_to_node.<span class="built_in">end</span>()) &#123; <span class="comment">// 没有这本书</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* node = it-&gt;second; <span class="comment">// 有这本书</span></span><br><span class="line">        <span class="built_in">remove</span>(node); <span class="comment">// 把这本书抽出来</span></span><br><span class="line">        <span class="built_in">push_front</span>(node); <span class="comment">// 放在最上面</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">capacity</span>(capacity), <span class="built_in">dummy</span>(<span class="keyword">new</span> <span class="built_in">Node</span>()) &#123;</span><br><span class="line">        dummy-&gt;prev = dummy;</span><br><span class="line">        dummy-&gt;next = dummy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node* node = <span class="built_in">get_node</span>(key); <span class="comment">// get_node 会把对应节点移到链表头部</span></span><br><span class="line">        <span class="keyword">return</span> node ? node-&gt;value : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node* node = <span class="built_in">get_node</span>(key); <span class="comment">// get_node 会把对应节点移到链表头部</span></span><br><span class="line">        <span class="keyword">if</span> (node) &#123; <span class="comment">// 有这本书</span></span><br><span class="line">            node-&gt;value = value; <span class="comment">// 更新 value</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        key_to_node[key] = node = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value); <span class="comment">// 新书</span></span><br><span class="line">        <span class="built_in">push_front</span>(node); <span class="comment">// 放在最上面</span></span><br><span class="line">        <span class="keyword">if</span> (key_to_node.<span class="built_in">size</span>() &gt; capacity) &#123; <span class="comment">// 书太多了</span></span><br><span class="line">            Node* back_node = dummy-&gt;prev;</span><br><span class="line">            key_to_node.<span class="built_in">erase</span>(back_node-&gt;key);</span><br><span class="line">            <span class="built_in">remove</span>(back_node); <span class="comment">// 去掉最后一本书</span></span><br><span class="line">            <span class="keyword">delete</span> back_node; <span class="comment">// 释放内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://hoshea99.github.io/2025/10/13/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Hoshea"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hoshea's Blog"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content=" | Hoshea's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2025/10/13/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">线程池</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-13 18:44:43 / 修改时间：19:57:29" itemprop="dateCreated datePublished" datetime="2025-10-13T18:44:43+08:00">2025-10-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/alg/" itemprop="url" rel="index"><span itemprop="name">alg</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>在操作系统那块也写了个线程池，实现方法略有不同，思路是一样的。这里都写一遍</p><h1 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="type">size_t</span> num_threads)</span>:stop_(false)&#123;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i&lt;num_threads;++i)&#123;</span><br><span class="line">            workers_.<span class="built_in">emplace_back</span>(<span class="built_in">bind</span>(&amp;ThreadPool::worker_loop,<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">            stop_ = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; worker:workers_)&#123;</span><br><span class="line">            worker.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(function&lt;<span class="type">void</span>()&gt; task)</span></span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        tasks_.<span class="built_in">push</span>(task);</span><br><span class="line">        cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> stop_;</span><br><span class="line">    vector&lt;thread&gt; workers_;</span><br><span class="line">    mutex mtx_;</span><br><span class="line">    condition_variable cv_;</span><br><span class="line">    queue&lt;function&lt;<span class="type">void</span>()&gt;&gt; tasks_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">worker_loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">                cv_.<span class="built_in">wait</span>(lock,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> stop_||!tasks_.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">                <span class="keyword">if</span>(stop_&amp;&amp;tasks.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">                task = tasks.<span class="built_in">front</span>();</span><br><span class="line">                tasks_.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">task</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个线程池比较清晰，简单，enqueue只能传输返回类型为void的没有参数的函数。</p><p>但是也有值得思考的东西：</p><ol><li><p>lock_guard和unique_lock有啥区别？</p><p>lock_guard：功能简单，只能在构造时加锁，析构时解锁<br>unique_lock：功能丰富，支持延迟加锁、手动解锁、转移所有权等</p></li><li><p>什么时候一定要用unique_lock？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. condition_variable::wait()</span></span><br><span class="line">cv_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> condition; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 需要手动控制锁的生命周期</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="comment">// ... 做一些工作</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();  <span class="comment">// 手动解锁</span></span><br><span class="line">    <span class="comment">// ... 做一些不需要锁的工作</span></span><br><span class="line">&#125;  <span class="comment">// 自动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 延迟加锁</span></span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx_, defer_lock)</span></span>;</span><br><span class="line"><span class="comment">// ... 其他代码</span></span><br><span class="line">lock.<span class="built_in">lock</span>();  <span class="comment">// 稍后加锁</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h1><p>该方法可以接收任意类型的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，创建指定数量的工作线程</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">size_t</span> threads) : <span class="built_in">stop</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i) &#123;</span><br><span class="line">            workers.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">                <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">                        <span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>();</span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>())</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加任务到线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span></span><br><span class="line"><span class="function">        -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">        );</span><br><span class="line">            </span><br><span class="line">        std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(stop)</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">            tasks.<span class="built_in">emplace</span>([task]()&#123; (*task)(); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        condition.<span class="built_in">notify_one</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数，等待所有任务完成</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        condition.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">for</span>(std::thread &amp;worker : workers)</span><br><span class="line">            worker.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; workers;      <span class="comment">// 工作线程</span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks; <span class="comment">// 任务队列</span></span><br><span class="line">    std::mutex queue_mutex;                <span class="comment">// 队列互斥锁</span></span><br><span class="line">    std::condition_variable condition;     <span class="comment">// 条件变量</span></span><br><span class="line">    <span class="type">bool</span> stop;                             <span class="comment">// 停止标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提交任务到线程池</span></span><br><span class="line">    <span class="keyword">auto</span> result = pool.<span class="built_in">enqueue</span>([](<span class="type">int</span> answer) &#123; </span><br><span class="line">        <span class="keyword">return</span> answer; </span><br><span class="line">    &#125;, <span class="number">42</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个新线程池代码比较复杂，本文将逐段讲解：</p><ul><li><p>工作线程逻辑</p><p>和老线程池一样</p></li><li><p>enqueue函数详解</p><ul><li><p>函数签名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt; </span>&#123;</span><br></pre></td></tr></table></figure><ol><li><code>template&lt;class F, class... Args&gt;</code> - 模板函数，接受任意可调用对象和参数</li><li><code>F&amp;&amp; f, Args&amp;&amp;... args</code> -完美转发参数</li><li>返回类型是<code>std::future&lt;返回值类型&gt;</code>，用于获取异步结果</li></ol></li><li><p>推导<code>f</code>函数的返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br></pre></td></tr></table></figure></li><li><p>包装f函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">    std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li>std::bind 将函数和参数绑定成无参函数</li><li>std::packaged_task 包装任务，使其能与future关联</li><li>std::shared_ptr 确保任务对象生命周期安全</li></ol></li><li><p>获取与任务关联的future，用于后续获取返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br></pre></td></tr></table></figure></li><li><p>加入任务队列，并返回future</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(stop)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">    tasks.<span class="built_in">emplace</span>([task]()&#123; (*task)(); &#125;);</span><br><span class="line">&#125;</span><br><span class="line">condition.<span class="built_in">notify_one</span>();</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>packaged_task以及类型擦除在C++专栏中会讲到，这里不重点讲述</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = pool.<span class="built_in">enqueue</span>([](<span class="type">int</span> answer) &#123; </span><br><span class="line">    <span class="keyword">return</span> answer; </span><br><span class="line">&#125;, <span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>在这个工作例子中，auto推导出的类型其实是：<code>std::future&lt;int&gt;</code></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://hoshea99.github.io/2025/10/13/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%BB%8F%E9%AA%8C/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Hoshea"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hoshea's Blog"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content=" | Hoshea's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2025/10/13/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%BB%8F%E9%AA%8C/" class="post-title-link" itemprop="url">linux性能调优经验</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-13 15:35:22 / 修改时间：15:51:23" itemprop="dateCreated datePublished" datetime="2025-10-13T15:35:22+08:00">2025-10-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="多线程异步问题怎么解决"><a href="#多线程异步问题怎么解决" class="headerlink" title="多线程异步问题怎么解决?"></a>多线程异步问题怎么解决?</h1><p>锁、原子操作、条件变量、线程池。</p><p>muduo里的方法是：</p><ol><li>one loop per thread 尽量减少跨线程通信</li><li>线程安全的跨线程调用，用runInloop提交任务</li></ol><h1 id="发生内存泄漏时如何排查问题"><a href="#发生内存泄漏时如何排查问题" class="headerlink" title="发生内存泄漏时如何排查问题"></a>发生内存泄漏时如何排查问题</h1><ol><li>gflags+umdh</li><li>代码内循环</li><li>共享内存泄露用查句柄泄露的方法排查</li></ol><h1 id="CPU占用超过70-，如何排查？"><a href="#CPU占用超过70-，如何排查？" class="headerlink" title="CPU占用超过70%，如何排查？"></a>CPU占用超过70%，如何排查？</h1><ol><li>死循环或者低效算法<br>比如增加休眠时间，优化算法<br>while(!ready)一直在占用CPU，要改成条件变量</li><li>多线程在锁上等待<br>减小锁的粒度</li><li>IO太多<br>比如日志等级太低，是否可以减少输出</li></ol><h1 id="性能调优经验案例"><a href="#性能调优经验案例" class="headerlink" title="性能调优经验案例"></a>性能调优经验案例</h1><ol><li><p>CPU调优</p><p>perf火焰图显示热点在map.find<br>改用unordered_map</p></li><li><p>内存调优</p><p>无内存泄漏但是内存碎片化严重<br>对象复用</p></li></ol><p>经验：</p><ol><li>先测量，再优化</li><li>优先优化热点函数</li><li>不要猜，用火焰图证明</li><li>多个小优化会带来大优化</li><li>优化完成需要回归测试</li></ol><h1 id="观测性能瓶颈时是什么资源问题"><a href="#观测性能瓶颈时是什么资源问题" class="headerlink" title="观测性能瓶颈时是什么资源问题"></a>观测性能瓶颈时是什么资源问题</h1><h2 id="观测"><a href="#观测" class="headerlink" title="观测"></a>观测</h2><p>vmstat 1指令 或者top也行</p><h3 id="CPU瓶颈判断："><a href="#CPU瓶颈判断：" class="headerlink" title="CPU瓶颈判断："></a>CPU瓶颈判断：</h3><table><thead><tr><th>监控指标</th><th>阈值条件</th><th>问题描述</th></tr></thead><tbody><tr><td><code>us + sy</code></td><td>&gt; 0.8 (80%)</td><td>CPU 资源紧张</td></tr><tr><td><code>wa</code></td><td>&gt; 5%</td><td>存在 I&#x2F;O 瓶颈</td></tr><tr><td><code>r</code> (运行队列长度)</td><td>&gt; 2 * CPU 核数</td><td>进程排队等待 CPU</td></tr></tbody></table><p>us：用户态进程占用CPU百分比</p><p>sy：内核态进程占用百分比</p><p>id：空闲百分比</p><p>wa：IO等待百分比</p><p>r：running 正在运行的进程数</p><h3 id="内存不足信号"><a href="#内存不足信号" class="headerlink" title="内存不足信号"></a>内存不足信号</h3><p>si&gt;0或so&gt;0 正在使用swap</p><p>si swap in</p><p>so swap out</p><p>原因解析：物理内存不足时，系统会将部分内存数据暂时移动到swap分区，导致性能下降，si&gt;0或so&gt;0导致正在频繁使用swap，是内存不足的明显信号</p><p>free持续下降 可能存在内存泄漏</p><p>cache很高但是应用慢 手动释放echo</p><h3 id="IO性能问题"><a href="#IO性能问题" class="headerlink" title="IO性能问题"></a>IO性能问题</h3><p>wa高+bi&#x2F;bo高</p><p>wa CPU等待IO完成的时间百分比<br>bi&#x2F;bo每秒从块设备读取，写入的块数</p><p>b&gt;0<br>不可中断睡眠状态的进程数（通常因为IO阻塞）</p><h3 id="上下文切换过多"><a href="#上下文切换过多" class="headerlink" title="上下文切换过多"></a>上下文切换过多</h3><p>cs&gt;10000&#x2F;秒&#x2F;核</p><p>上下文切换次数，即四核机器&gt;40000就要注意了</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul><li><p>针对1：</p><ol><li><p>us高，通过top找到高CPU进程，优化算法、减少循环</p></li><li><p>sy高，减少系统调用（高频文件读写改成批量操作）</p></li><li><p>wa&gt;5%，结合后面的IO部分处理</p></li><li><p>r&gt;2*CPU核数，扩容CPU资源，降低进程并发度</p></li></ol></li><li><p>针对2：</p><ol><li><p>情况1：si&#x2F;so &gt; 0（频繁使用Swap）</p><p><strong>紧急处理：</strong></p><p>释放缓存：echo 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches（临时方案）。</p><p>终止非关键进程：kill -9 或 oom-killer 自动处理。</p><p><strong>长期优化：</strong></p><p>扩容物理内存。</p><p>调整Swappiness：sysctl vm.swappiness&#x3D;10（降低Swap倾向）。</p><p>优化应用内存：检查内存泄漏（如 valgrind）、减少缓存大小。</p></li><li><p>情况2：free持续下降（内存泄漏）</p><p>使用 pmap 或 jmap（Java）分析进程内存分布。</p><p>监控工具：smem、valgrind 定位泄漏代码。</p></li><li><p>情况3：cache高但应用慢</p><p>手动释放缓存（同上），或优化应用IO模式（如改用直接IO）。</p></li></ol></li><li><p>针对3：</p><ol><li><p>wa高+bi&#x2F;bo高</p><p>iotop 查看进程级IO</p><p>使用更快的存储（ssd）</p><p>调整文件系统(ext4换成xfs)</p><p>减少随机写</p></li><li><p>如果b&gt;0</p><p>检查磁盘健康，分散IO负载</p></li></ol></li><li><p>针对4：</p><ol><li>检查是否因为过多的线程或者频繁的锁竞争，优化代码，降低锁粒度。调整调度策略</li></ol></li></ul><h1 id="内存泄漏一般什么场景会出现？"><a href="#内存泄漏一般什么场景会出现？" class="headerlink" title="内存泄漏一般什么场景会出现？"></a>内存泄漏一般什么场景会出现？</h1><ol><li>未调用free或者malloc回收</li><li>异常抛出后跳过清理代码</li><li>共享内存的释放与申请和堆内存不一样，也是要释放的</li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://hoshea99.github.io/2025/10/13/gdb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Hoshea"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hoshea's Blog"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content=" | Hoshea's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2025/10/13/gdb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">gdb常用命令</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-13 15:28:35 / 修改时间：15:31:39" itemprop="dateCreated datePublished" datetime="2025-10-13T15:28:35+08:00">2025-10-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>顺口溜：冷若冰霜驱动盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">l list <span class="comment"># 查看源码</span></span><br><span class="line"></span><br><span class="line">r run <span class="comment"># 运行程序</span></span><br><span class="line"></span><br><span class="line">b <span class="built_in">break</span> <span class="comment"># 设置断点</span></span><br><span class="line"></span><br><span class="line">s step <span class="comment"># 单步执行（进入函数）</span></span><br><span class="line"></span><br><span class="line">q quit <span class="comment"># 退出gdb</span></span><br><span class="line"></span><br><span class="line">d delete <span class="comment"># 删除断点</span></span><br><span class="line"></span><br><span class="line">p <span class="built_in">print</span> <span class="comment"># 打印变量值</span></span><br></pre></td></tr></table></figure><p>再加几个常用的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bt backtrace <span class="comment"># 查看调用栈</span></span><br><span class="line"></span><br><span class="line">c <span class="built_in">continue</span> <span class="comment"># 继续执行</span></span><br><span class="line"></span><br><span class="line">n next <span class="comment"># 单步执行（不进入函数）</span></span><br><span class="line"></span><br><span class="line">f finish <span class="comment"># 执行完当前函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">disable</span> 2 <span class="comment"># 禁用编号为2的断点</span></span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://hoshea99.github.io/2025/10/13/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Hoshea"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hoshea's Blog"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content=" | Hoshea's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2025/10/13/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">linux常用命令</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-13 15:11:28 / 修改时间：15:25:51" itemprop="dateCreated datePublished" datetime="2025-10-13T15:11:28+08:00">2025-10-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span>       <span class="comment"># 显示当前目录</span></span><br><span class="line"><span class="built_in">cd</span>        <span class="comment"># 切换目录</span></span><br><span class="line"><span class="built_in">ls</span>        <span class="comment"># 列出目录内容</span></span><br><span class="line"><span class="built_in">cp</span>        <span class="comment"># 复制文件/目录</span></span><br><span class="line">    <span class="built_in">cp</span> file.txt backup/</span><br><span class="line">    <span class="built_in">cp</span> -r dir1/ dir2/</span><br><span class="line"><span class="built_in">mv</span>        <span class="comment"># 移动文件/目录，也用于重命名</span></span><br><span class="line">	<span class="built_in">mv</span> 源文件 目标文件</span><br><span class="line"><span class="built_in">touch</span>     <span class="comment"># 创建空文件或更新文件时间戳</span></span><br><span class="line"><span class="built_in">mkdir</span>     <span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">rmdir</span>     <span class="comment"># 移除空目录</span></span><br><span class="line"><span class="built_in">rm</span>        <span class="comment"># 删除文件/目录</span></span><br><span class="line">find      <span class="comment"># 查找文件</span></span><br><span class="line">	find 路径 选项 表达式</span><br><span class="line">	find /home -name <span class="string">&quot;*.txt&quot;</span></span><br><span class="line"><span class="built_in">which</span>     <span class="comment"># 查找命令位置</span></span><br><span class="line">whereis   <span class="comment"># 查找程序相关文件</span></span><br></pre></td></tr></table></figure><h1 id="文件查看和处理"><a href="#文件查看和处理" class="headerlink" title="文件查看和处理"></a>文件查看和处理</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span>       <span class="comment"># 显示文件内容</span></span><br><span class="line">    <span class="built_in">cat</span> tmp.txt</span><br><span class="line">    <span class="built_in">cat</span> -n tmp.txt 显示行号</span><br><span class="line">less/more <span class="comment"># 分页查看文件</span></span><br><span class="line">    less large_file.log <span class="comment">#支持翻页。less比more好用，不介绍more了</span></span><br><span class="line"><span class="built_in">head</span>      <span class="comment"># 查看文件前几行</span></span><br><span class="line"><span class="built_in">tail</span>      <span class="comment"># 查看文件后几行</span></span><br><span class="line"><span class="built_in">wc</span>        <span class="comment"># 统计文件行数、字数、字节数</span></span><br><span class="line">diff      <span class="comment"># 比较文件差异</span></span><br><span class="line">grep      <span class="comment"># 搜索文本</span></span><br><span class="line">    grep <span class="string">&quot;error&quot;</span> server.log <span class="comment">#直接查</span></span><br><span class="line">    grep -r <span class="string">&quot;404&quot;</span> /var/log  <span class="comment">#递归查找目录</span></span><br></pre></td></tr></table></figure><h1 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ps        <span class="comment"># 查看进程</span></span><br><span class="line">    ps -ef | grep nginx</span><br><span class="line">top/htop  <span class="comment"># 系统进程监控</span></span><br><span class="line"><span class="built_in">kill</span>      <span class="comment"># 终止进程</span></span><br><span class="line">    <span class="built_in">kill</span> -9 5678</span><br><span class="line">free -h   <span class="comment"># 查看剩余内存</span></span><br><span class="line"><span class="built_in">df</span> -h     <span class="comment"># 查看磁盘使用情况</span></span><br><span class="line"><span class="built_in">du</span> -sh    <span class="comment"># 查看目录大小</span></span><br><span class="line">netstat   <span class="comment"># 网络连接状态</span></span><br><span class="line">ss        <span class="comment"># 更现代的网络状态查看</span></span><br></pre></td></tr></table></figure><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ping      <span class="comment"># 测试网络连通性</span></span><br><span class="line">telnet    <span class="comment"># 测试端口连通性</span></span><br><span class="line">curl      <span class="comment"># 发送HTTP请求</span></span><br><span class="line">wget      <span class="comment"># 下载文件</span></span><br><span class="line">nc/netcat <span class="comment"># 网络调试工具</span></span><br><span class="line">ifconfig/ip <span class="comment"># 网络接口配置</span></span><br></pre></td></tr></table></figure><h1 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span>     <span class="comment"># 修改文件权限</span></span><br><span class="line">    <span class="built_in">chmod</span> 777 config.conf</span><br><span class="line">    <span class="built_in">chmod</span> (u/g/o/a)+(r/w/x) script.sh</span><br></pre></td></tr></table></figure><h1 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar       <span class="comment"># 打包压缩</span></span><br><span class="line">    tar -zcvf log.tar.gz /var/log</span><br><span class="line">    tar -xvf archive.tar -C /var/log</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://hoshea99.github.io/2025/10/13/cmake/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Hoshea"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hoshea's Blog"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content=" | Hoshea's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2025/10/13/cmake/" class="post-title-link" itemprop="url">cmake</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-13 14:43:52 / 修改时间：15:03:46" itemprop="dateCreated datePublished" datetime="2025-10-13T14:43:52+08:00">2025-10-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="生成静态-动态链接库"><a href="#生成静态-动态链接库" class="headerlink" title="生成静态&#x2F;动态链接库"></a>生成静态&#x2F;动态链接库</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">math_library/</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include/</span><br><span class="line">│   └── math_utils.h</span><br><span class="line">└── src/</span><br><span class="line">    └── math_utils.cpp</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>头文件：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>源文件：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math_utiles.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Cmake:</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MathLibrary VERSION <span class="number">1.0</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(math_shared SHARED src/math_utils.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(math_static STATIC src/math_utils.cpp)</span><br></pre></td></tr></table></figure><h1 id="写一个程序用到上面的动态库"><a href="#写一个程序用到上面的动态库" class="headerlink" title="写一个程序用到上面的动态库"></a>写一个程序用到上面的动态库</h1><p><strong>目录：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">project_root/</span><br><span class="line">├── math_library/</span><br><span class="line">│   ├── include/</span><br><span class="line">│   │   └── math_utiles.h</span><br><span class="line">│   ├── src/</span><br><span class="line">│   │   ├── math_utiles.cpp</span><br><span class="line">│   │   └── CMakeLists.txt</span><br><span class="line">│   ├── lib/</span><br><span class="line">│   │   └── libmath_shared.so</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">├── math_test/</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   └── test_math.cpp</span><br><span class="line">└── CMakeLists.txt (顶层)</span><br></pre></td></tr></table></figure><p><strong>源文件：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;math_utiles.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;3+4=&quot;</span>&lt;&lt;<span class="built_in">add</span>(<span class="number">3</span>,<span class="number">4</span>)&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;3*4=&quot;</span>&lt;&lt;<span class="built_in">multiply</span>(<span class="number">3</span>,<span class="number">4</span>)&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Cmake:</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MathTest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置库文件路径</span></span><br><span class="line"><span class="keyword">set</span>(MATH_UTILS_LIB <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libmath_shared.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建测试程序</span></span><br><span class="line"><span class="keyword">add_executable</span>(test_math test_math.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接库并包含头文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(test_math PRIVATE <span class="variable">$&#123;MATH_UTILS_LIB&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(test_math PRIVATE </span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/../math_library/<span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果库不在当前目录，需要复制或创建符号链接</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="variable">$&#123;MATH_UTILS_LIB&#125;</span>)</span><br><span class="line">    <span class="keyword">message</span>(WARNING <span class="string">&quot;libmath_shared.so not found in current directory&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h1 id="Cmake问题"><a href="#Cmake问题" class="headerlink" title="Cmake问题"></a>Cmake问题</h1><h2 id="PRIVATE-PUBLIC-INTERFACE区别"><a href="#PRIVATE-PUBLIC-INTERFACE区别" class="headerlink" title="PRIVATE PUBLIC INTERFACE区别"></a>PRIVATE PUBLIC INTERFACE区别</h2><ul><li><p>public</p><p>A和依赖A的目标都能使用</p></li><li><p>private</p><p>仅A使用</p></li><li><p>interface</p><p>仅依赖A的目标能使用</p></li></ul><h2 id="动态链接库对比静态链接库有哪些好处"><a href="#动态链接库对比静态链接库有哪些好处" class="headerlink" title="动态链接库对比静态链接库有哪些好处"></a>动态链接库对比静态链接库有哪些好处</h2><ol><li>节省磁盘空间</li><li>更新维护时不需要重新编译</li><li>dlopen可以按需加载</li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Hoshea</span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>